/*        Hierarchy Builder: algebraic hierarchies made easy
    This software is released under the terms of the MIT license              */

namespace context {

% [declare TheType Parameters Factories Clauses] postulates a
% (section) context with all the mixins provided by the factories and all
% the structure instances we can derive on TheType from these. Clauses
% contain mixin-src for each postulated mixin
pred declare i:term, i:list term, i:list-w-params factoryname, o:list prop, o:list constant.
declare TheType TheParams GRFSwP MSL CL :-  std.do! [
  factories-provide GRFSwP MLwP,
  apply-w-params MLwP TheParams TheType MLwAllArgs,
  std.fold MLwAllArgs (pr [] []) (private.postulate-mixin TheType) (pr CL MSL),
  std.forall MSL (ms\ log.coq.env.accumulate current "hb.db" (clause _ _ ms)),
].

/* ------------------------------------------------------------------------- */
/* ----------------------------- private code ------------------------------ */
/* ------------------------------------------------------------------------- */

namespace private {

% Given a type T, a fresh number N, and a mixin M it postulates
% a variable "mN" inhabiting M applied to T and
% all its dependencies, previously postulated and associated
% to the corresponding mixin using mixin-for
pred postulate-mixin i:term, i:w-args mixinname, i:pair (list constant) (list prop),
                     o:pair (list constant) (list prop).
postulate-mixin TheType (triple M Ps T) (pr CL MSL) (pr OutCL [MC|MSL]) :- MSL => std.do! [
  Name is "mixin_" ^ {gref->modname M},

  if-verbose (coq.say "HB: postulate" Name "on" {coq.term->string T}),

  synthesis.infer-all-mixin-args Ps T M Ty,
  std.assert-ok! (coq.typecheck Ty _) "postulate-mixin: Ty illtyped",
  log.coq.env.add-section-variable-noimplicits Name Ty C,

  MC = mixin-src T M (global (const C)),
  MC => instance.declare-all TheType {findall-classes} NewCSL,
  std.append CL {std.map NewCSL snd} OutCL
].

}}
